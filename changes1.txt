I can see the issue now. Looking at both versions - the original working one (height_map.rs) and the current one
  (height_map_new_speed.rs) - there's a critical bug in the coordinate calculation for sampling blocks.

● Update Todos
  ⎿  [ ] Fix coordinate calculation bug in sample_block_state call

● The bug is in line 237 of height_map_new_speed.rs. I'm comparing the calls:

  Working version (height_map.rs:128):
  .sample_block_state(
      Vector3::new(sample_start_x, sample_start_y, sample_start_z),
      Vector3::new(local_x_i32, local_y_i32, local_z_i32),
      &mut proto.surface_height_estimate_sampler,
  )

  Broken version (height_map_new_speed.rs:237):
  .sample_block_state(
      Vector3::new(cell_bounds.sample_start_x, block_y, cell_bounds.sample_start_z),
      Vector3::new(local_x as i32, 0, local_z as i32),
      &mut proto.surface_height_estimate_sampler,
  )

  The issue is in the second parameter - the local offset vector. In the working version, it correctly passes
  (local_x_i32, local_y_i32, local_z_i32), but in the broken version, it passes (local_x, 0, local_z) - the Y
  component is 0 instead of the proper local_y offset!

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 2 additions and 2 removals
       234                    let block_state = proto
       235                        .noise_sampler
       236                        .sample_block_state(
       237 -                          Vector3::new(cell_bounds.sample_start_x, block_y,
     cell_bounds.sample_start_z),
       238 -                          Vector3::new(local_x as i32, 0, local_z as i32),
       237 +                          Vector3::new(cell_bounds.sample_start_x, sample_start_y,
     cell_bounds.sample_start_z),
           + cell_bounds.sample_start_z),
       238 +                          Vector3::new(local_x as i32, local_y, local_z as i32),
       239                            &mut proto.surface_height_estimate_sampler,
       240                        )
       241                        .unwrap_or(proto.default_block);

● Wait, I need to calculate the correct sample_start_y value. Looking at the working version, it calculates
  sample_start_y properly. Let me add that calculation:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Error: No changes to make: old_string and new_string are exactly the same.

● Now I need to fix the local_y parameter - I need to pass the proper local_y value, not 0:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 1 addition and 1 removal
       235                        .noise_sampler
       236                        .sample_block_state(
       237                            Vector3::new(cell_bounds.sample_start_x, sample_start_y,
             cell_bounds.sample_start_z),
       238 -                          Vector3::new(local_x as i32, local_y, local_z as i32),
       238 +                          Vector3::new(local_x as i32, local_y as i32, local_z as i32),
       239                            &mut proto.surface_height_estimate_sampler,
       240                        )
       241                        .unwrap_or(proto.default_block);

● But wait, I still need the local_y value to be available in this function. Looking at the function signature, I
  need to pass it from process_y_layers_in_cell. Let me add it to the process_blocks_at_height signature:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 1 addition and 1 removal
       194                let delta_y = local_y as f64 * inv_vertical;
       195                proto.noise_sampler.interpolate_y(delta_y);
       196
       197 -              if self.process_blocks_at_height(proto, params, state, cell_bounds, block_y,
     inv_horizontal) {
           - inv_horizontal) {
       197 +              if self.process_blocks_at_height(proto, params, state, cell_bounds, block_y, local_y as
     i32, sample_start_y, inv_horizontal) {
           + i32, sample_start_y, inv_horizontal) {
       198                    return true;
       199                }
       200            }

● Now I need to update the function signature:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 2 additions
       209            state: &mut GenerationState,
       210            cell_bounds: &CellBounds,
       211            block_y: i32,
       212 +          local_y: i32,
       213 +          sample_start_y: i32,
       214            inv_horizontal: f64,
       215        ) -> bool {
       216            // Loop through all blocks in this horizontal layer

● Now I need to use the passed local_y parameter in the sample_block_state call:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 1 addition and 1 removal
       237                        .noise_sampler
       238                        .sample_block_state(
       239                            Vector3::new(cell_bounds.sample_start_x, sample_start_y,
             cell_bounds.sample_start_z),
       240 -                          Vector3::new(local_x as i32, local_y as i32, local_z as i32),
       240 +                          Vector3::new(local_x as i32, local_y, local_z as i32),
       241                            &mut proto.surface_height_estimate_sampler,
       242                        )
       243                        .unwrap_or(proto.default_block);

● Now let's test if this fix resolves the accuracy issue: