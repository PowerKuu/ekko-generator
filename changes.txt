  ⎿  [ ] Apply careful optimizations to height_map_new_speed.rs while maintaining accuracy

● I'll apply simple, safe optimizations while keeping the accuracy intact. Looking at the speed-guide.md and the
  working code, I'll focus on:

  1. Pre-allocate working arrays to avoid repeated allocations
  2. Use early termination when all surfaces are found
  3. Cache frequently used calculations
  4. Optimize memory access patterns

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 23 additions
       295        estimated_surface_y: i32,
       296    }
       297
       298 +  // Pre-allocated working arrays to avoid repeated allocations
       299 +  struct CoordinateCache {
       300 +      block_coords: Vec<(i32, i32, i32)>,
       301 +      chunk_coords: Vec<(usize, usize)>,
       302 +      deltas: Vec<(f64, f64)>,
       303 +  }
       304 +
       305 +  impl CoordinateCache {
       306 +      fn with_capacity(capacity: usize) -> Self {
       307 +          Self {
       308 +              block_coords: Vec::with_capacity(capacity),
       309 +              chunk_coords: Vec::with_capacity(capacity),
       310 +              deltas: Vec::with_capacity(capacity),
       311 +          }
       312 +      }
       313 +
       314 +      fn clear(&mut self) {
       315 +          self.block_coords.clear();
       316 +          self.chunk_coords.clear();
       317 +          self.deltas.clear();
       318 +      }
       319 +  }
       320 +
       321    impl GenerationState {
       322        fn new(initial_estimate: i32) -> Self {
       323            Self {

● Now I'll optimize the main processing function to use pre-calculated coordinates and early termination:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 35 additions and 24 removals
       213            sample_start_y: i32,
       214            inv_horizontal: f64,
       215        ) -> bool {
       216 -          // Loop through all blocks in this horizontal layer
       216 +          // Pre-calculate coordinates for cache-friendly access
       217 +          let mut pending_blocks = Vec::with_capacity((params.horizontal_cell_block_count *
           + params.horizontal_cell_block_count) as usize);
       218 +
       219 +          // Collect blocks that need processing (skip already found surfaces)
       220            for local_x in 0..params.horizontal_cell_block_count {
       221                let block_x = cell_bounds.cell_start_x + local_x as i32;
       222                let chunk_local_x = (block_x - params.start_block_x) as usize;
     ...
       223                    let chunk_local_z = (block_z - params.start_block_z) as usize;
       224
       225                    // Skip if we already found surface for this column
       226 -                  if state.surface_found[chunk_local_x][chunk_local_z] {
       227 -                      continue;
       226 +                  if !state.surface_found[chunk_local_x][chunk_local_z] {
       227 +                      pending_blocks.push((local_x, local_z, chunk_local_x, chunk_local_z, block_x,
     block_z));
           + block_z));
       228                    }
       229 +              }
       230 +          }
       231
       232 -                  // Sample this specific block
       233 -                  let delta_x = local_x as f64 * inv_horizontal;
       234 -                  let delta_z = local_z as f64 * inv_horizontal;
       235 -                  proto.noise_sampler.interpolate_x(delta_x);
       236 -                  proto.noise_sampler.interpolate_z(delta_z);
       232 +          // Early termination if no blocks need processing
       233 +          if pending_blocks.is_empty() {
       234 +              return state.columns_completed >= 256;
       235 +          }
       236
       237 -                  let block_state = proto
       238 -                      .noise_sampler
       239 -                      .sample_block_state(
       240 -                          Vector3::new(cell_bounds.sample_start_x, sample_start_y,
     cell_bounds.sample_start_z),
           - cell_bounds.sample_start_z),
       241 -                          Vector3::new(local_x as i32, local_y, local_z as i32),
       242 -                          &mut proto.surface_height_estimate_sampler,
       243 -                      )
       244 -                      .unwrap_or(proto.default_block);
       237 +          // Process blocks with pre-calculated coordinates
       238 +          for (local_x, local_z, chunk_local_x, chunk_local_z, block_x, block_z) in pending_blocks {
       239 +              // Sample this specific block
       240 +              let delta_x = local_x as f64 * inv_horizontal;
       241 +              let delta_z = local_z as f64 * inv_horizontal;
       242 +              proto.noise_sampler.interpolate_x(delta_x);
       243 +              proto.noise_sampler.interpolate_z(delta_z);
       244
       245 -                  proto.set_block_state(&Vector3::new(block_x, block_y, block_z), block_state);
       245 +              let block_state = proto
       246 +                  .noise_sampler
       247 +                  .sample_block_state(
       248 +                      Vector3::new(cell_bounds.sample_start_x, sample_start_y,
           + cell_bounds.sample_start_z),
       249 +                      Vector3::new(local_x as i32, local_y, local_z as i32),
       250 +                      &mut proto.surface_height_estimate_sampler,
       251 +                  )
       252 +                  .unwrap_or(proto.default_block);
       253
       254 -                  // If we found a solid block, mark it as the surface height
       255 -                  if !block_state.is_air() {
       256 -                      self.handle_surface_found(proto, state, chunk_local_x, chunk_local_z, block_y);
       257 -
       258 -                      if state.columns_completed >= 256 {
       259 -                          return true; // All 16x16 columns completed
       260 -                      }
       254 +              proto.set_block_state(&Vector3::new(block_x, block_y, block_z), block_state);
       255 +
       256 +              // If we found a solid block, mark it as the surface height
       257 +              if !block_state.is_air() {
       258 +                  self.handle_surface_found(proto, state, chunk_local_x, chunk_local_z, block_y);
       259 +
       260 +                  if state.columns_completed >= 256 {
       261 +                      return true; // All 16x16 columns completed
       262                    }
       263                }
       264            }

● Now let me add better early termination checks and optimize the surface estimation:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 5 additions
       142            cell_x: u16,
       143        ) -> bool {
       144            for cell_z in 0..params.horizontal_cells {
       145 +              // Early termination check
       146 +              if state.columns_completed >= 256 {
       147 +                  return true;
       148 +              }
       149 +
       150                if self.process_xz_cell(proto, params, state, cell_x, cell_z) {
       151                    return true; // All columns completed
       152                }

● Now let's optimize the surface estimate update to be more efficient:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 13 additions and 5 removals
       345        }
       346
       347        fn update_surface_estimate(&mut self, samples_for_convergence: usize) {
       348 -          if self.surface_samples.len() <= samples_for_convergence {
       349 -              self.estimated_surface_y = self.surface_samples.iter().sum::<i32>() /
     self.surface_samples.len() as i32;
           - self.surface_samples.len() as i32;
       348 +          let len = self.surface_samples.len();
       349 +
       350 +          if len <= samples_for_convergence {
       351 +              // Use simple average for early samples - more efficient than iterator
       352 +              let mut sum = 0i32;
       353 +              for &sample in &self.surface_samples {
       354 +                  sum = sum.wrapping_add(sample);
       355 +              }
       356 +              self.estimated_surface_y = sum / len as i32;
       357            } else {
       358 -              let weight = 0.1;
       359 -              let latest_sample = *self.surface_samples.last().unwrap();
       360 -              self.estimated_surface_y = ((1.0 - weight) * self.estimated_surface_y as f32 + weight *
     latest_sample as f32) as i32;
           - latest_sample as f32) as i32;
       358 +              // Weighted average favoring recent samples - avoid float operations
       359 +              let latest_sample = unsafe { *self.surface_samples.get_unchecked(len - 1) };
       360 +              // Use integer arithmetic: old * 9 + new * 1, then divide by 10
       361 +              self.estimated_surface_y = (self.estimated_surface_y * 9 + latest_sample) / 10;
       362            }
       363        }
       364    }

● Now let's add a final optimization to pre-calculate some commonly used values:

● Update(src\lib\height_map_new_speed.rs)
  ⎿  Updated src\lib\height_map_new_speed.rs with 6 additions and 1 removal
       49
       50            proto.noise_sampler.sample_start_density();
       51
       52 -          // Process each column of cells along the X axis
       52 +          // Process each column of cells along the X axis with early termination
       53            for cell_x in 0..params.horizontal_cells {
       54 +              // Early global termination check
       55 +              if state.columns_completed >= 256 {
       56 +                  break;
       57 +              }
       58 +
       59                proto.noise_sampler.sample_end_density(cell_x as u8);
       60
       61                if self.process_x_cells(proto, &params, &mut state, cell_x) {
